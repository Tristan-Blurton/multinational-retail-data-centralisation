import pandas as pd
import numpy as np
import yaml


class DataCleaning:
    # A class used to clean data from different sources.

    def clean_user_data(self, user_df):
        # A method to clean the user data from the RDS database provided.
        # Remove double index:
        user_df.set_index("index", inplace=True)
        # Converting all column types based on pandas defaults:
        user_df = user_df.convert_dtypes()
        # Converting 'date_of_birth' and 'join_date' to datetime format:
        user_df.date_of_birth = pd.to_datetime(user_df.date_of_birth,
                                               format="mixed",
                                               errors="coerce")
        user_df.join_date = pd.to_datetime(user_df.join_date,
                                           format="mixed",
                                           errors="coerce")
        # Dropping rows with null values both previously existing 
        # and those generated by to_datetime() where no date format was found:
        user_df.dropna(inplace=True)
        # Replacing mistyped country code from 'GGB' to 'GB':
        user_df["country_code"].replace({"GGB":"GB"}, inplace=True)
        # Filtering out rows with user age outside of reasonable range 
        # (there aren't any removed in this case). 
        # 'min_user_age' and 'max_user_age' can be adjusted as desired:
        now = pd.Timestamp.now()
        min_user_age = np.timedelta64(16, "Y")
        max_user_age = np.timedelta64(120, "Y")
        user_df = user_df[(user_df.date_of_birth + min_user_age < now) 
                              | (user_df.date_of_birth + max_user_age > now)]
        # Filtering out rows where 'join_date' is in the future or 'join_date' 
        # is earlier than 'date_of_birth'.
        user_df = user_df[(user_df.join_date < now)
                              & (user_df.join_date > user_df.date_of_birth)]
        # Filtering out rows where 'user_uuid' is in an incorrect format
        # (there are none in this case).
        user_df = user_df[user_df.user_uuid.str.match(
                          "^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$")]
        return user_df
    
    def __card_number_length_check(self, card_data):
        """Drop rows with incorrect card number lengths."""
        # Load dictionary relating card lengths to providers:
        with open("parameters/number_lengths.yaml", "r") as file:
            number_lengths = dict(yaml.safe_load(file))
        # Initialise list:
        invalid_numbers = []

        # Create a list of series of card numbers of invalid length:
        # Create two boolean masks per iteration:
        #  - 'provider_mask' is true when the card provider matches the 
        # loop iteration's current card number length. 
        #  - 'incorrect_length_mask' is true when the length of the card number
        #  does not match the iteration's current card number length.  
        # Create a new series of card numbers where both these masks are true.
        # Append this series to the list of series 'invalid_numbers' each iteration.  
        for card_length in number_lengths.keys():
            provider_mask = card_data.card_provider.isin(number_lengths[card_length])
            incorrect_length_mask = ~card_data.card_number.str.match(f"^\d{card_length}$")                     
            invalid_numbers.append(card_data.card_number[provider_mask & incorrect_length_mask])

        # Concatenate the list of series into one series:
        invalid_numbers = pd.concat(invalid_numbers)
        # Convert the series to a python list:
        invalid_numbers = invalid_numbers.tolist()
        # Drop rows where card numbers are invalid:
        card_data = card_data[~card_data.card_number.isin(invalid_numbers)]
        return(card_data)

    def __card_data_reformat(self, card_data):
        """Change card data dataframe columns to appropriate data types."""
        card_data.card_number = card_data.card_number.astype("int64", errors="raise")
        card_data.expiry_date = pd.to_datetime(card_data.expiry_date,
                                       format="%m/%y",
                                       errors="raise",)
        card_data.card_provider = card_data.card_provider.astype("string")
        card_data.date_payment_confirmed = pd.to_datetime(card_data.date_payment_confirmed,
                                                  format="mixed",
                                                  errors="raise")
        return(card_data)
    
    def clean_card_data(self, card_data):
        """Clean card data."""
        # Drop rows with null values:
        card_data.dropna(inplace=True)
        # Remove rows where the card number has any non-digit character:
        card_data.card_number = card_data.card_number.astype("string")
        card_data = card_data[card_data.card_number.str.match("^\d+$")] 
        # Drop rows with invalid card number lengths:
        card_data = self.__card_number_length_check(card_data)
        # Change columns to appropriate data types:
        card_data = self.__card_data_reformat(card_data)
        # Correct index:
        card_data.reset_index(inplace=True, drop=True)
        card_data.index.rename("Index", inplace=True)
        return (card_data)